// src/utils/verifyHashpack.ts
// Utility function for verifying digital signatures generated by HashPack wallet (Ed25519).
//
// Uses the `@noble/ed25519` library for cryptographic verification.
// Handles the complexity of dynamically importing an ESM module (`@noble/ed25519`) within a CommonJS project.
// Includes helper functions for converting hex strings to `Uint8Array`.
// Functions:
// - `verifyHashpackSignature(message, signature, publicKey)`: Verifies an Ed25519 signature.
// Used by authentication services to confirm wallet ownership for Hedera-based addresses.

import { Buffer } from 'buffer';

// Cache for the ed25519 verify function to avoid repeated dynamic imports
let ed25519Verify: ((signature: Uint8Array, message: Uint8Array, publicKey: Uint8Array) => boolean) | null = null;

/**
 * Dynamically imports and caches the ed25519 verify function
 * Required because @noble/ed25519 is an ES module and we're in a CommonJS environment
 * 
 * @returns {Promise<Function>} The ed25519 verify function
 * @throws {Error} If the ed25519 module fails to load
 */
async function getEd25519Verifier(): Promise<(signature: Uint8Array, message: Uint8Array, publicKey: Uint8Array) => boolean> {
  if (!ed25519Verify) {
    try {
      // Dynamic import to handle ESM module in CommonJS
      const { verify } = await import('@noble/ed25519');
      ed25519Verify = verify;
    } catch (error) {
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  throw new Error(`Failed to load ed25519 module: ${errorMessage}`);
}
  }
  return ed25519Verify;
}

/**
 * Verifies a HashPack Ed25519 signature
 * 
 * @param {string} message - The original message that was signed
 * @param {string} signature - Hex-encoded signature to verify
 * @param {string} publicKey - Hex-encoded public key for verification
 * 
 * @returns {Promise<boolean>} True if signature is valid, false otherwise
 * 
 * @example
 * const isValid = await verifyHashpackSignature(
 *   'Hello World',
 *   'a1b2c3...',
 *   'd4e5f6...'
 * );
 */
export const verifyHashpackSignature = async (
  message: string,
  signature: string,
  publicKey: string
): Promise<boolean> => {
  try {
    // Validate input parameters
    if (!message || !signature || !publicKey) {
      console.error('Missing required parameters for signature verification');
      return false;
    }

    if (typeof message !== 'string' || typeof signature !== 'string' || typeof publicKey !== 'string') {
      console.error('Invalid parameter types for signature verification');
      return false;
    }

    // Get the verifier function (dynamically imports if needed)
    const verify = await getEd25519Verifier();

    // Convert string inputs to Uint8Arrays required by ed25519
    const messageBytes = new TextEncoder().encode(message);
    const signatureBytes = hexToUint8Array(signature);
    const publicKeyBytes = hexToUint8Array(publicKey);

    // Validate byte array lengths
    if (signatureBytes.length !== 64) {
      console.error(`Invalid signature length: expected 64 bytes, got ${signatureBytes.length}`);
      return false;
    }

    if (publicKeyBytes.length !== 32) {
      console.error(`Invalid public key length: expected 32 bytes, got ${publicKeyBytes.length}`);
      return false;
    }

    // Perform the actual signature verification
    return verify(signatureBytes, messageBytes, publicKeyBytes);

  } catch (error) {
    console.error('Signature verification failed:', error);
    return false;
  }
};

/**
 * Converts a hex string to a Uint8Array
 * 
 * @param {string} hexString - Hex string to convert
 * @returns {Uint8Array} Converted byte array
 * 
 * @throws {Error} If hex string is invalid
 */
function hexToUint8Array(hexString: string): Uint8Array {
  // Remove any hex prefixes or whitespace
  const cleanHex = hexString.replace(/^0x/, '').replace(/\s/g, '');
  
  // Validate hex format
  if (!/^[0-9a-fA-F]+$/.test(cleanHex)) {
    throw new Error('Invalid hex string');
  }

  if (cleanHex.length % 2 !== 0) {
    throw new Error('Hex string must have even length');
  }

  // Convert hex to byte array
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const byte = parseInt(cleanHex.substring(i * 2, i * 2 + 2), 16);
    if (isNaN(byte)) {
      throw new Error('Invalid hex byte');
    }
    bytes[i] = byte;
  }

  return bytes;
}

/**
 * Alternative: Verifies a signature using Buffer instead of manual hex conversion
 * (Use this if you prefer Buffer-based conversion)
 * 
 * @param {string} message - The original message
 * @param {string} signature - Hex-encoded signature
 * @param {string} publicKey - Hex-encoded public key
 * 
 * @returns {Promise<boolean>} True if signature is valid
 */
export const verifyHashpackSignatureWithBuffer = async (
  message: string,
  signature: string,
  publicKey: string
): Promise<boolean> => {
  try {
    const verify = await getEd25519Verifier();
    
    const messageBytes = new TextEncoder().encode(message);
    const signatureBytes = Uint8Array.from(Buffer.from(signature, 'hex'));
    const publicKeyBytes = Uint8Array.from(Buffer.from(publicKey, 'hex'));
    
    return verify(signatureBytes, messageBytes, publicKeyBytes);
  } catch (error) {
    console.error('Buffer-based signature verification failed:', error);
    return false;
  }
};

// Export the verifier getter for testing or advanced use cases
export { getEd25519Verifier };