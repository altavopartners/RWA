// src/utils/verifyEthereum.ts
// Utility functions for verifying digital signatures generated by Ethereum-compatible wallets (e.g., MetaMask).
//
// Uses the `ethers.js` library to perform signature recovery and verification (ECDSA/secp256k1).
// Functions:
// - `verifyMetaMaskSignature(message, signature, expectedAddress)`: Verifies a standard personal message signature.
// - Alternative and helper functions for edge cases or detailed verification results.
// Used by authentication services to confirm wallet ownership for Ethereum-based addresses.

import { ethers } from "ethers";

/**
 * Verify an Ethereum signature against an expected address.
 * 
 * @param message - Exact string that was signed
 * @param signature - Signature hex string (0x...)
 * @param expectedAddress - Expected Ethereum address of the signer
 * @returns True if signature is valid and belongs to expectedAddress
 */
export function verifyMetaMaskSignature(
  message: string,
  signature: string,
  expectedAddress: string
): boolean {
  try {
    const recovered = ethers.verifyMessage(message, signature);

    return recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
  } catch (err) {
    console.error("[verifyMetaMaskSignature] Error:", (err as Error).message);
    return false;
  }
}

/**
 * Alternative method: Verify using UTF-8 encoded bytes
 * 
 * @note Advanced usage only â€” in most cases, use verifyMetaMaskSignature.
 */
export function verifyMetaMaskSignatureAlt(
  message: string,
  signature: string,
  expectedAddress: string
): boolean {
  try {
    const messageBytes = ethers.toUtf8Bytes(message);
    const recovered = ethers.verifyMessage(messageBytes, signature);

    return recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
  } catch (err) {
    console.error("[verifyMetaMaskSignatureAlt] Error:", (err as Error).message);
    return false;
  }
}

/**
 * Verify signature against a precomputed message hash.
 * Useful when signing digests instead of raw strings.
 */
export function verifySignatureWithHash(
  messageHash: string,
  signature: string,
  expectedAddress: string
): boolean {
  try {
    // For message hashes, use recoverAddress directly
    const recovered = ethers.recoverAddress(messageHash, signature);
    return recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
  } catch (err) {
    console.error("[verifySignatureWithHash] Error:", (err as Error).message);
    return false;
  }
}

/**
 * Hash a message using Ethereum's prefix (EIP-191).
 * 
 * @param message - String to hash
 * @returns Hex string of hashed message
 */
export function hashMessage(message: string): string {
  return ethers.hashMessage(message);
}

/**
 * Detailed verification: Returns object with recovered address and error info.
 */
export function verifySignatureDetailed(
  message: string,
  signature: string,
  expectedAddress: string
): {
  isValid: boolean;
  recoveredAddress?: string;
  error?: string;
} {
  try {
    const recovered = ethers.verifyMessage(message, signature);
    const isValid = recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();

    return {
      isValid,
      recoveredAddress: recovered,
      ...(!isValid && { error: "Recovered address does not match expected address" }),
    };
  } catch (err) {
    const errorMessage = (err as Error).message;
    return {
      isValid: false,
      error: errorMessage,
    };
  }
}
