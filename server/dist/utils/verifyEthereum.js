"use strict";
// src/utils/verifyEthereum.ts
// Utility functions for verifying digital signatures generated by Ethereum-compatible wallets (e.g., MetaMask).
//
// Uses the `ethers.js` library to perform signature recovery and verification (ECDSA/secp256k1).
// Functions:
// - `verifyMetaMaskSignature(message, signature, expectedAddress)`: Verifies a standard personal message signature.
// - Alternative and helper functions for edge cases or detailed verification results.
// Used by authentication services to confirm wallet ownership for Ethereum-based addresses.
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyMetaMaskSignature = verifyMetaMaskSignature;
exports.verifyMetaMaskSignatureAlt = verifyMetaMaskSignatureAlt;
exports.verifySignatureWithHash = verifySignatureWithHash;
exports.hashMessage = hashMessage;
exports.verifySignatureDetailed = verifySignatureDetailed;
const ethers_1 = require("ethers");
/**
 * Verify an Ethereum signature against an expected address.
 *
 * @param message - Exact string that was signed
 * @param signature - Signature hex string (0x...)
 * @param expectedAddress - Expected Ethereum address of the signer
 * @returns True if signature is valid and belongs to expectedAddress
 */
function verifyMetaMaskSignature(message, signature, expectedAddress) {
    try {
        const recovered = ethers_1.ethers.verifyMessage(message, signature);
        return recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
    }
    catch (err) {
        console.error("[verifyMetaMaskSignature] Error:", err.message);
        return false;
    }
}
/**
 * Alternative method: Verify using UTF-8 encoded bytes
 *
 * @note Advanced usage only â€” in most cases, use verifyMetaMaskSignature.
 */
function verifyMetaMaskSignatureAlt(message, signature, expectedAddress) {
    try {
        const messageBytes = ethers_1.ethers.toUtf8Bytes(message);
        const recovered = ethers_1.ethers.verifyMessage(messageBytes, signature);
        return recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
    }
    catch (err) {
        console.error("[verifyMetaMaskSignatureAlt] Error:", err.message);
        return false;
    }
}
/**
 * Verify signature against a precomputed message hash.
 * Useful when signing digests instead of raw strings.
 */
function verifySignatureWithHash(messageHash, signature, expectedAddress) {
    try {
        // For message hashes, use recoverAddress directly
        const recovered = ethers_1.ethers.recoverAddress(messageHash, signature);
        return recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
    }
    catch (err) {
        console.error("[verifySignatureWithHash] Error:", err.message);
        return false;
    }
}
/**
 * Hash a message using Ethereum's prefix (EIP-191).
 *
 * @param message - String to hash
 * @returns Hex string of hashed message
 */
function hashMessage(message) {
    return ethers_1.ethers.hashMessage(message);
}
/**
 * Detailed verification: Returns object with recovered address and error info.
 */
function verifySignatureDetailed(message, signature, expectedAddress) {
    try {
        const recovered = ethers_1.ethers.verifyMessage(message, signature);
        const isValid = recovered.toLowerCase().trim() === expectedAddress.toLowerCase().trim();
        return {
            isValid,
            recoveredAddress: recovered,
            ...(!isValid && { error: "Recovered address does not match expected address" }),
        };
    }
    catch (err) {
        const errorMessage = err.message;
        return {
            isValid: false,
            error: errorMessage,
        };
    }
}
//# sourceMappingURL=verifyEthereum.js.map