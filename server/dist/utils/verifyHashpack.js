"use strict";
// src/utils/verifyHashpack.ts
// Utility function for verifying digital signatures generated by HashPack wallet (Ed25519).
//
// Uses the `@noble/ed25519` library for cryptographic verification.
// Handles the complexity of dynamically importing an ESM module (`@noble/ed25519`) within a CommonJS project.
// Includes helper functions for converting hex strings to `Uint8Array`.
// Functions:
// - `verifyHashpackSignature(message, signature, publicKey)`: Verifies an Ed25519 signature.
// Used by authentication services to confirm wallet ownership for Hedera-based addresses.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyHashpackSignatureWithBuffer = exports.verifyHashpackSignature = void 0;
exports.getEd25519Verifier = getEd25519Verifier;
const buffer_1 = require("buffer");
// Cache for the ed25519 verify function to avoid repeated dynamic imports
let ed25519Verify = null;
/**
 * Dynamically imports and caches the ed25519 verify function
 * Required because @noble/ed25519 is an ES module and we're in a CommonJS environment
 *
 * @returns {Promise<Function>} The ed25519 verify function
 * @throws {Error} If the ed25519 module fails to load
 */
async function getEd25519Verifier() {
    if (!ed25519Verify) {
        try {
            // Dynamic import to handle ESM module in CommonJS
            const { verify } = await Promise.resolve().then(() => __importStar(require('@noble/ed25519')));
            ed25519Verify = verify;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            throw new Error(`Failed to load ed25519 module: ${errorMessage}`);
        }
    }
    return ed25519Verify;
}
/**
 * Verifies a HashPack Ed25519 signature
 *
 * @param {string} message - The original message that was signed
 * @param {string} signature - Hex-encoded signature to verify
 * @param {string} publicKey - Hex-encoded public key for verification
 *
 * @returns {Promise<boolean>} True if signature is valid, false otherwise
 *
 * @example
 * const isValid = await verifyHashpackSignature(
 *   'Hello World',
 *   'a1b2c3...',
 *   'd4e5f6...'
 * );
 */
const verifyHashpackSignature = async (message, signature, publicKey) => {
    try {
        // Validate input parameters
        if (!message || !signature || !publicKey) {
            console.error('Missing required parameters for signature verification');
            return false;
        }
        if (typeof message !== 'string' || typeof signature !== 'string' || typeof publicKey !== 'string') {
            console.error('Invalid parameter types for signature verification');
            return false;
        }
        // Get the verifier function (dynamically imports if needed)
        const verify = await getEd25519Verifier();
        // Convert string inputs to Uint8Arrays required by ed25519
        const messageBytes = new TextEncoder().encode(message);
        const signatureBytes = hexToUint8Array(signature);
        const publicKeyBytes = hexToUint8Array(publicKey);
        // Validate byte array lengths
        if (signatureBytes.length !== 64) {
            console.error(`Invalid signature length: expected 64 bytes, got ${signatureBytes.length}`);
            return false;
        }
        if (publicKeyBytes.length !== 32) {
            console.error(`Invalid public key length: expected 32 bytes, got ${publicKeyBytes.length}`);
            return false;
        }
        // Perform the actual signature verification
        return verify(signatureBytes, messageBytes, publicKeyBytes);
    }
    catch (error) {
        console.error('Signature verification failed:', error);
        return false;
    }
};
exports.verifyHashpackSignature = verifyHashpackSignature;
/**
 * Converts a hex string to a Uint8Array
 *
 * @param {string} hexString - Hex string to convert
 * @returns {Uint8Array} Converted byte array
 *
 * @throws {Error} If hex string is invalid
 */
function hexToUint8Array(hexString) {
    // Remove any hex prefixes or whitespace
    const cleanHex = hexString.replace(/^0x/, '').replace(/\s/g, '');
    // Validate hex format
    if (!/^[0-9a-fA-F]+$/.test(cleanHex)) {
        throw new Error('Invalid hex string');
    }
    if (cleanHex.length % 2 !== 0) {
        throw new Error('Hex string must have even length');
    }
    // Convert hex to byte array
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        const byte = parseInt(cleanHex.substring(i * 2, i * 2 + 2), 16);
        if (isNaN(byte)) {
            throw new Error('Invalid hex byte');
        }
        bytes[i] = byte;
    }
    return bytes;
}
/**
 * Alternative: Verifies a signature using Buffer instead of manual hex conversion
 * (Use this if you prefer Buffer-based conversion)
 *
 * @param {string} message - The original message
 * @param {string} signature - Hex-encoded signature
 * @param {string} publicKey - Hex-encoded public key
 *
 * @returns {Promise<boolean>} True if signature is valid
 */
const verifyHashpackSignatureWithBuffer = async (message, signature, publicKey) => {
    try {
        const verify = await getEd25519Verifier();
        const messageBytes = new TextEncoder().encode(message);
        const signatureBytes = Uint8Array.from(buffer_1.Buffer.from(signature, 'hex'));
        const publicKeyBytes = Uint8Array.from(buffer_1.Buffer.from(publicKey, 'hex'));
        return verify(signatureBytes, messageBytes, publicKeyBytes);
    }
    catch (error) {
        console.error('Buffer-based signature verification failed:', error);
        return false;
    }
};
exports.verifyHashpackSignatureWithBuffer = verifyHashpackSignatureWithBuffer;
//# sourceMappingURL=verifyHashpack.js.map